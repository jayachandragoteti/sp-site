"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const follow_redirects_1 = require("follow-redirects");
const stream_1 = require("stream");
const includePattern = /(?:##\s+<include\s+href="([^"]+)">.*?##\s+<\/include>\s*)|([^\n]*\n?)/gs;
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
var ErrorHandling;
(function (ErrorHandling) {
    ErrorHandling["embedAsComments"] = "embedAsComments";
    ErrorHandling["throwImmediate"] = "throwImmediate";
})(ErrorHandling = exports.ErrorHandling || (exports.ErrorHandling = {}));
//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Utility functions
//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
const gets = (url) => new Promise((resolve, reject) => {
    follow_redirects_1.https
        .get(url, (response) => {
        let body = "";
        response.on("data", (chunk) => (body += chunk));
        response.on("end", () => resolve(body));
    })
        .on("error", reject);
});
//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class IncludesFilter extends stream_1.Transform {
    constructor(options) {
        var _a;
        super();
        this._errorHandling = (_a = options === null || options === void 0 ? void 0 : options.errorHandling) !== null && _a !== void 0 ? _a : ErrorHandling.embedAsComments;
    }
}
exports.IncludesFilter = IncludesFilter;
//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
/** Transforms a stream removing all the contents between the include tags. */
class IncludesFilterClean extends IncludesFilter {
    constructor(options) {
        super(options);
    }
    _transform(chunk, _encoding, callback) {
        if (chunk instanceof Buffer) {
            chunk = chunk.toString("utf8");
        }
        const matches = chunk.matchAll(includePattern);
        if (matches) {
            const result = [];
            for (const groups of matches) {
                if (groups[0].match(/^##\s+<include\s+/)) {
                    result.push(`## <include href="${groups[1]}">`);
                    result.push(`## </include>\n`);
                }
                else {
                    result.push(groups[0].trim());
                }
            }
            this.push(result.join("\n"), "utf8"); // Make sure to only push once. This allows us to assume the chunk is the whole stream.
        }
        else {
            this.push(chunk, "utf8");
        }
        callback();
    }
}
exports.IncludesFilterClean = IncludesFilterClean;
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
/** Transforms a stream replacing all the contents between the include tags with updated content from the given URL. Fetch errors are by default embedded in the steam as comments. */
class IncludesFilterSmudge extends IncludesFilter {
    constructor(options) {
        super(options);
    }
    _transform(chunk, _encoding, callback) {
        if (chunk instanceof Buffer) {
            chunk = chunk.toString("utf8");
        }
        (async () => {
            const matches = chunk.matchAll(includePattern);
            if (matches) {
                const result = [];
                for (const groups of matches) {
                    if (groups[0].match(/^##\s+<include\s+/)) {
                        try {
                            result.push(`## <include href="${groups[1]}">`);
                            result.push(await gets(groups[1]));
                            result.push(`## </include>\n`);
                        }
                        catch (e) {
                            if (this._errorHandling === ErrorHandling.embedAsComments) {
                                result.push(
                                // Add a comment with the error.
                                `# Error fetching source: ${e}`
                                    .replace(/\r\n|\r/g, "\n")
                                    .split("\n")
                                    .join("\n# "));
                                result.push(groups[0].trim()); // Make sure that a replace is nearly a no-op other than the error.
                            }
                            else {
                                throw e;
                            }
                        }
                    }
                    else {
                        result.push(groups[0].trim());
                    }
                }
                this.push(result.join("\n"), "utf8"); // Make sure to only push once. This allows us to assume the chunk is the whole stream.
            }
            else {
                this.push(chunk, "utf8");
            }
        })().then(() => {
            callback();
        });
    }
}
exports.IncludesFilterSmudge = IncludesFilterSmudge;
